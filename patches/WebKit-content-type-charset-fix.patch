------------------------------------------------------------------------
r250899 | carlosgc@webkit.org | 2019-10-09 15:42:05 +0800 (ä¸‰, 09 10æœˆ 2019) | 24 lines

REGRESSION(r250597): [GTK][WPE] 2.27.1 shows HTML content as text/plain in custom protocols when passing a charset in content type
https://bugs.webkit.org/show_bug.cgi?id=202633

Reviewed by Å½an DoberÅ¡ek.

Source/WebKit:

This is a regression of the switch to use the new custom protocols implementation. Before r250597, we extracted
the mime type and charset from content type in the network process, but we are now sending the response directly
from the UI process, so we need to do that when building our response. Rename the mime_type parameter as
content_type to avoid confusion, since it's documented as the content type.

* UIProcess/API/glib/WebKitURISchemeRequest.cpp:
(webkitURISchemeRequestReadCallback):
(webkit_uri_scheme_request_finish):
* UIProcess/API/gtk/WebKitURISchemeRequest.h:
* UIProcess/API/wpe/WebKitURISchemeRequest.h:

Tools:

Add a test case.

* TestWebKitAPI/Tests/WebKitGLib/TestWebKitWebContext.cpp:
(testWebContextURIScheme):

Index: trunk/Source/WebKit/UIProcess/API/glib/WebKitURISchemeRequest.cpp
===================================================================
--- trunk/Source/WebKit/UIProcess/API/glib/WebKitURISchemeRequest.cpp	(revision 250898)
+++ trunk/Source/WebKit/UIProcess/API/glib/WebKitURISchemeRequest.cpp	(revision 250899)
@@ -27,6 +27,7 @@
 #include "WebKitWebView.h"
 #include "WebPageProxy.h"
 #include <WebCore/GUniquePtrSoup.h>
+#include <WebCore/HTTPParsers.h>
 #include <WebCore/ResourceError.h>
 #include <WebCore/URLSoup.h>
 #include <libsoup/soup.h>
@@ -69,7 +70,7 @@
     GRefPtr<GCancellable> cancellable;
     char readBuffer[gReadBufferSize];
     uint64_t bytesRead;
-    CString mimeType;
+    CString contentType;
 };
 
 WEBKIT_DEFINE_TYPE(WebKitURISchemeRequest, webkit_uri_scheme_request, G_TYPE_OBJECT)
@@ -178,7 +179,8 @@
         return;
 
     if (!priv->bytesRead) {
-        ResourceResponse response(priv->task->request().url(), String::fromUTF8(priv->mimeType.data()), priv->streamLength, emptyString());
+        ResourceResponse response(priv->task->request().url(), extractMIMETypeFromMediaType(priv->contentType.data()), priv->streamLength, emptyString());
+        response.setTextEncodingName(extractCharsetFromMediaType(priv->contentType.data()));
         priv->task->didReceiveResponse(response);
     }
 
@@ -198,11 +200,11 @@
  * @request: a #WebKitURISchemeRequest
  * @stream: a #GInputStream to read the contents of the request
  * @stream_length: the length of the stream or -1 if not known
- * @mime_type: (allow-none): the content type of the stream or %NULL if not known
+ * @content_type: (allow-none): the content type of the stream or %NULL if not known
  *
  * Finish a #WebKitURISchemeRequest by setting the contents of the request and its mime type.
  */
-void webkit_uri_scheme_request_finish(WebKitURISchemeRequest* request, GInputStream* inputStream, gint64 streamLength, const gchar* mimeType)
+void webkit_uri_scheme_request_finish(WebKitURISchemeRequest* request, GInputStream* inputStream, gint64 streamLength, const gchar* contentType)
 {
     g_return_if_fail(WEBKIT_IS_URI_SCHEME_REQUEST(request));
     g_return_if_fail(G_IS_INPUT_STREAM(inputStream));
@@ -213,7 +215,7 @@
     request->priv->streamLength = streamLength == -1 ? 0 : streamLength;
     request->priv->cancellable = adoptGRef(g_cancellable_new());
     request->priv->bytesRead = 0;
-    request->priv->mimeType = mimeType;
+    request->priv->contentType = contentType;
     g_input_stream_read_async(inputStream, request->priv->readBuffer, gReadBufferSize, RunLoopSourcePriority::AsyncIONetwork, request->priv->cancellable.get(),
         reinterpret_cast<GAsyncReadyCallback>(webkitURISchemeRequestReadCallback), g_object_ref(request));
 }
Index: trunk/Source/WebKit/UIProcess/API/gtk/WebKitURISchemeRequest.h
===================================================================
--- trunk/Source/WebKit/UIProcess/API/gtk/WebKitURISchemeRequest.h	(revision 250898)
+++ trunk/Source/WebKit/UIProcess/API/gtk/WebKitURISchemeRequest.h	(revision 250899)
@@ -75,7 +75,7 @@
 webkit_uri_scheme_request_finish       (WebKitURISchemeRequest *request,
                                         GInputStream           *stream,
                                         gint64                  stream_length,
-                                        const gchar            *mime_type);
+                                        const gchar            *content_type);
 
 WEBKIT_API void
 webkit_uri_scheme_request_finish_error (WebKitURISchemeRequest *request,
Index: trunk/Tools/TestWebKitAPI/Tests/WebKitGLib/TestWebKitWebContext.cpp
===================================================================
--- trunk/Tools/TestWebKitAPI/Tests/WebKitGLib/TestWebKitWebContext.cpp	(revision 250898)
+++ trunk/Tools/TestWebKitAPI/Tests/WebKitGLib/TestWebKitWebContext.cpp	(revision 250899)
@@ -305,6 +305,21 @@
     test->waitUntilLoadFinished();
     g_assert_true(test->m_loadEvents.contains(LoadTrackingTest::ProvisionalLoadFailed));
 
+    static const char* charsetHTML = "<html><body><p id='emoji'>ðŸ™‚</p></body></html>";
+    test->registerURISchemeHandler("charset", charsetHTML, -1, "text/html; charset=\"UTF-8\"");
+    test->loadURI("charset:test");
+    test->waitUntilLoadFinished();
+    mainResourceDataSize = 0;
+    mainResourceData = test->mainResourceData(mainResourceDataSize);
+    g_assert_cmpint(mainResourceDataSize, ==, strlen(charsetHTML));
+    g_assert_cmpint(strncmp(mainResourceData, charsetHTML, mainResourceDataSize), ==, 0);
+    GUniqueOutPtr<GError> error;
+    auto* javascriptResult = test->runJavaScriptAndWaitUntilFinished("document.getElementById('emoji').innerText", &error.outPtr());
+    g_assert_nonnull(javascriptResult);
+    g_assert_no_error(error.get());
+    GUniquePtr<char> emoji(WebViewTest::javascriptResultToCString(javascriptResult));
+    g_assert_cmpstr(emoji.get(), ==, "ðŸ™‚");
+
     test->registerURISchemeHandler("empty", nullptr, 0, "text/html");
     test->m_loadEvents.clear();
     test->loadURI("empty:nothing");
------------------------------------------------------------------------
